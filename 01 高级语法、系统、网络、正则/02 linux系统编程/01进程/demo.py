'''
linux下python 创建子进程的原理： os.fork()方法 的原理
 
为了实现并发、多任务，我们可以在主程序种开启一个进程或者线程。
在类unix操作系统当中(非windows)，可以用python的os.fork() 方法 在主进程上创建一个子进程

os.fork()：
    这句话执行过后，就会创建出一个新的进程来，被我们创建出来的进程我们叫她子进程，当前进程我们叫它主进程
    子进程会复制主进程所有内容，包括代码、变量、各种资源。他们两个一摸一样，
    两个进程此时同时从os.fork()结束的那个时间点向下执行相同的代码。
    这个方法有一个返回值，在主进程中接收到的返回值是子进程的pid、子进程中接收到的是0
获得当前进程的pid： os.getpid()
获得当前进程父进程的pid: os.getppid()

执行下面代码，如果在ide中，发现子进程不一定会不会输出信息。如果在终端中，发现子进程信息和主进程信息都会输出。
因为两个进程之间相互独立，我们能控制的只是当前主进程，如果主进程子进程先结束了，就不等子进程的输出消息了。
'''
import os
pid = os.fork()
if pid == 0:
    print("我是子进程%s,我的父进程是%s"%(os.getpid,os.getppid  ) )
else:
    print("我是父进程%s,我创建了子进程%s"%( os.getpid,pid ))




'''
进程产生垃圾:
    僵尸进程: 子进程先死掉，父进程还没死掉的父进程
    孤儿进程：父进程死了，子进程还没死掉的子进程
 
 在操作系统中，子进程死掉后，内存等资源都由父进程进行管理回收和释放
 如果子进程还没结束，父进程就运行结束了，那么创建出来的子进程就会产生系统垃圾没有其它进程负责释放
 所以 主进程创建出来的子进程要主进程自己进行管理，把他们收集回收资源
 父进程用os.wait() 可以进行资源回收，会返回两个值 进程的pid 和 一个整数:0代表成功 负数代表失败
'''
import os

pid = os.fork()
#子进程会进入这个分支
if pid == 0 :
    print("我是子进程%s，我的父进程是%s"%( os.getpid(),os.getppid() ))
#父进程会进入这个分支
else :
    print("我是父进程%s,我创建了子进程%s"%( os.getpid(),pid ))
    print("我要收集子进程资源：")
    son_pid , result = os.wait()
    print(son_pid , result )



'''
进程之间不共享变量：
进程是独立占一部分内存空间的
如果我们在主进程中创建一个子进程，子进程是在当前主进程之外申请了一块额外内存，把主进程所有代码和资源复制一份自己来运行。
所以，主进程和子进程是不共享全局变量的。他们分别在自己的内存空间当中维护自己的变量空间
'''
import os
import time
num = 100
pid = os.fork()
#子进程当中
if pid == 0 :
    print("这里是子进程：")
    print(num)
    num = 10
    print( num )
#主进程中
else:
    time.sleep(3)
    print("这里是主进程：")
    print( num )




'''
在程序中多次调用fork()
一共会产生多少进程？？？

当一个进程调用了fork() 都会生成另一个子进程
然后当前进程和子进程同时fork()语句继续向下执行

'''
import os
os.fork()  #主进程会产生一个子进程，两个进程从这里开始继续向下进行
os.fork() #两个进程到这里，分别会给自己创建一个子进程，结果 会有四个进程从这里继续向下
os.fork() # 四个进程到这里，每个进程都会给自己再创建一个子进程。结果会形成八个进程
print("哈哈哈")    #会打印出八条哈哈哈



