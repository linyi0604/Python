tcp 程序流程：
tcp服务器：
    1 创建套接字
    2 绑定ip和端口
    3 listen()监听客户端的连接状态
    4 accept()把建立完的链接复制状态
        生成一个新的套接字
    5 recv()阻塞等待客户端数据请求
    6 处理请求业务
    7 send() 完成数据发送给客户端
    8 关闭真正与客户端通讯的套接字
tcp客户端：
    1 创建套接字
    2 connect()连接服务器（三次握手）
    3 send()发送请求给服务器
    4 阻塞等待服务器的处理结果
    5 关闭套接字 释放资源

tcp的十种状态：
    tcp三次握手的状态：
    1 listen : 服务器初始状态 处于监听状态
    2 SYN_SENT: 客户端已经发送SYN连接请求的状态
    3 SYN_REVD: 服务器收到SYN请求并发送SYN+ACK应答之后的状态
    4 ESTABLISHED: 客户端收到服务器的SYN+ACK的应答后发送ACK回复的状态
                   服务器收到ACK回复后的状态
    tcp四次挥手的状态：
    1 FIN_WAIT_1:客户端第一次发送FIN+ACK请求关闭后的状态 第一次挥手
    2 CLOSE_WAIT:服务器收到FIN+ACK并发送了ACK回复后的状态 第二次回收
    3 LAST_ACK: 服务器发送FIN回复请求后的状态 第三次挥手
    4 FIN_WAIT_2:客户端接收到了ACK回复后的状态
    5 TIME_WAIT: 客户端受到了FIN请求并发送ACK回复后 的状态
    6 CLOSE: 客户端四次挥手后一段时间之后的状态
             服务器收到第四次回收最后一次ACK请求之后的状态

tcp的第十一种状态：
    很特殊的状态，在四次挥手中，
    客户端发送FIN关闭请求之后，没有收到对方的ACK回复，而是收到了对方的FIN请求，
    相当于两方都在发送FIN 这种情况，两方都在处于closing状态，两方都在主动请求关闭套接字


短连接：每次发送数据都新开辟链接，发送完马上就关闭连接
    例如：访问网站
    缺点：频繁建立关闭链接 占用资源
    优点：不会长期占用socket资源
长连接：连接之后很久不关闭，一直等待传送数据
    例如：看视频
    优点：一次建立过程和关闭过程
    缺点：长期占用socket资源

MSL:数据包在网络中最长的存活时间
2MSL：确保最后一次挥手ACK可以送到被关闭的一方

服务器关闭以后如果向立即重启 需要设置重用地址
    setsockopt( SL_SOCKET , SOCK_REUSEADDR , 1 )


linux命令： netstat -n 查看当前的程序端口情况


复习：
tcp服务器：
    1 创建他姐自
    2 绑定端口和ip
    3 监听客户端
    4 阻塞等待客户端的到来 listen
    5 阻塞等待客户端数据请求 accept
    6 处理请求
    7 把处理的结果返回给客户端
    8 关闭用于客户端通讯的套接字

tcp客户端：
    1 创建套接字
    2 链接服务器 connect 三次握手
    3 发送数据请求
    4 阻塞等待服务器的处理结果
    5 关闭套接字

tcp的十个状态：
    三次握手：
        客户端： SYN_SENT -> 连接状态
        服务器： listen -> SYN_RCVD ->连接状态

    四次挥手
        客户端:连接状态->FIN_WAIT_1 -> FIN_WAIT_2 -> TIME_WAIT(2MSL) -> CLOSED
        服务器:连接状态->CLOSE_WAIT -> LAST_ACK -> CLOSED
            等待2MSL的作用： 1 保证最后一个ack包可以到达服务器
                           2 保证前面发送的包在网络中被丢弃
    TIME_WAIT 设置setsockopt地址复用









