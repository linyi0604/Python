'''
python中垃圾回收机制：
    引用计数为主
      分代收集为辅
      
    引用计数：内存中对象引用的个数进行记录。当引用个数为0的时候就释放内存空间。
            优点：不需要拿出统一时间进行回收，把回收的时间分担在平时，
            缺点： 每一个对象维护一个引用数量，浪费资源
                    无法解决循环引用的问题
    分代收集： python中有0、1、2 三代变量链
                每隔一段时间搜索一次0代链表：
                    给循环引用的对象引用计数-1
                    循环一次之后，没有被释放的变量放到1代链表上
                扫描n次0代链表后会扫描一次1代链表：
                    对循环引用的对象引用计数-1
                    循环一次将引用计数>0的变量放在2代链表上
                扫描n次1代链表后会扫描2代链表
                
    引用计数+1的情况：  创建变量
                        对象被 引用
                        对象被传入函数做参数
                        对象被存入容器当中
    引用计数-1的情况：  对象被消亡
                        别名被赋其他值
                        对象离开作用域
                        容器被消亡
'''

'''
小整数池：   python认为 -5到256  的小整数是常用的，所以常驻内存。变量复制的时候会获取这个对象的引用
大整数池：   超出小整数范围的大整数在相同代码段当中 会使用相同的对象引用，不同代码段使用不同对象引用
intern机制： 对于 字符串，会使用相同的引用
'''
#查看一个变量的引用计数
import sys
a = "hahah"
print(sys.getrefcount(a))

#获取垃圾回收机制的阀值
import gc
'''返回了（700，10，10） 表示对0代链表700次扫描之后，扫描一次1代链表
                                对1代链表扫描10次之后扫描2代链表
                                
'''
print(gc.get_threshold())


#手动进行一次垃圾回收
gc.collect()
#手动停掉python的垃圾回收机制
#gc.disable( )

'''
手动写一个循环引用，关掉python的垃圾回收 会令内存泄漏
'''
'''
class A(object):
    pass
gc.disable()
while True:
    a = A()
    b = A()
    a.a = b
    b.a = a
    del a
    del b
'''
