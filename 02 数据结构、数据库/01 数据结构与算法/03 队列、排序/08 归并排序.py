'''
学习归并排序的过程是十分痛苦的。它并不常用，看起来时间复杂度好像是几种排序中最低的，比快排的时间复杂度还要低，但是它的执行速度不是最快的。
很多朋友不理解时间复杂度低为什么运行速度不一定快，这个不清楚的伙伴可以看下我之前发表的文章http://www.cnblogs.com/Lin-Yi/p/7301535.html
看完之后也许你会对时间复杂度有一个新的认识。

我谈的观点往往不是官方的定义，我希望能帮助更多基础薄弱的同学读懂思想~

归并排序：
    先分开再合并，分开成单个元素，合并的时候按照正确顺序合并

    假如我们有一个n个数的数列，下标从0到n-1
    1 我们按照 n//2 把这个数列分成两个小的数列
    2 把两个小数列 再按照新长度的一半 把每个小数列都分成两个更小的
    。。。一直这样重复，一直到每一个数分开了
    比如：    6 5 4 3 2 1
        第一次 n=6 n//2=3 分成      6 5 4      3 2 1
        第二次 n=3 n//2=1 分成    6   5 4    3   2 1
        第三次 n=1的部分不分了
                n=2 n//2=1 分成     5   4      2  1

    之后是合并排序的过程：
    3 分开之后我们按照最后分开的两个数比较大小形成正确顺序后组合绑定
        刚刚举得例子 最后一行最后分开的数排序后绑定   变成     4 5     1 2
        排序后倒数第二行变成    6   4 5       3    12
    4 对每组数据按照上次分开的结果，进行排序后绑定
        6 和 4 5(两个数绑定了)  进行排序
        3 和 1 2(两个数绑定了)  进行排序
        排完后 上述例子第一行变成了  4 5 6      1 2 3  两组数据
    5 对上次分开的两组进行排序
        拿着 4 5 6     1 2 3两个数组，进行排序
        每个数组拿出第一个数，小的那个拿出来放在第一位 1 拿出来了，   变成4 5 6    2 3
        每个数组拿出第一个书比较小的那个放在下一个位置  1 2被拿出来，  待排序 4 5 6      2
        每个数组拿出第一个书比较小的那个放在下一个位置  1 2 3 被拿出来，  待排序 4 5 6
        如果一个数组空了，说明另一个数组一定比排好序的数组最后一个大 追加就可以结果 1 2 3 4 5 6
    相当于我们每次拿到两个有序的列表进行合并，分别从两个列表第一个元素比较，把小的拿出来，在拿新的第一个元素比较，把小的拿出来
        这样一直到两个列表空了 就按顺序合并了两个列表

    结束

时间复杂度： 最好最坏都是 O( n log n )
稳定性：稳定
缺点：每次拆分数组都要开心的数组， 每次合并数组都要开新数组，空间复杂度很大

在python中这样实现
'''


def merge_sort(li):
    # 不断递归调用自己一直到拆分成成单个元素的时候就返回这个元素，不再拆分了
    if len(li) == 1:
        return li

    # 取拆分的中间位置
    mid = len(li) // 2
    # 拆分过后左右两侧子串
    left = li[:mid]
    right = li[mid:]

    # 对拆分过后的左右再拆分 一直到只有一个元素为止
    # 最后一次递归时候ll和lr都会接到一个元素的列表
    # 最后一次递归之前的ll和rl会接收到排好序的子序列
    ll = merge_sort(left)
    rl = merge_sort(right)

    # 我们对返回的两个拆分结果进行排序后合并再返回正确顺序的子列表
    # 这里我们调用拎一个函数帮助我们按顺序合并ll和lr
    return merge(ll, rl)


# 这里接收两个列表
def merge(left, right):
    # 从两个有顺序的列表里边依次取数据比较后放入result
    # 每次我们分别拿出两个列表中最小的数比较，把较小的放入result
    result = []
    while len(left) > 0 and len(right) > 0:
        # 为了保持稳定性，当遇到相等的时候优先把左侧的数放进结果列表，因为left本来也是大数列中比较靠左的
        if left[0] <= right[0]:
            result.append(left.pop(0))
        else:
            result.append(right.pop(0))
    # while循环出来之后 说明其中一个数组没有数据了，我们把另一个数组添加到结果数组后面
    result += left
    result += right
    return result


if __name__ == '__main__':
    li = [5, 4, 3, 2, 1]
    li2 = merge_sort(li)
    print(li2)


























# #归并排序
# # [1,2,7,10,9,8]
# 
# '''
# 最优时间复杂度： O( n log n )
# 最坏时间复杂度: O( n log n )
# 稳定性 ： 稳定
# '''
#
# def merge_sort(li):
#     if len(li) == 1:
#         return li
#
#     mid = len(li)//2
#
#     left = li[:mid]
#     right = li[mid:]
#
#     ll = merge_sort(left)   #接收下层返回的的数据
#     rl = merge_sort(right)  #接受下层返回的数据
#
#     # merge = ll + rl
#     # print(merge)
#     # return merge
#
#     merge_result = merge( ll , rl )#把下层返回的数据组合成有序集合
#
#     return merge_result #把下层返回的数据组合再返回给上一层
#
#
# def merge( left , right ):
#     result = []
#     l = 0 #左边集合的下标
#     r = 0 #右边集合的下标
#     while l < len(left) and r<len(right) :
#         if left[l] <= right[r]:
#             result.append( left[l] )
#             l += 1
#         else:
#             result.append( right[r] )
#             r += 1
#     #此时有一个集合已经遍历完了
#     result += left[l:]
#     result += right[r:]
#     return result
#
#
# if __name__ == '__main__':
#     li = [1,2,7,6,5,9,8,3]
#     li2 =merge_sort(li)
#     print(li2)